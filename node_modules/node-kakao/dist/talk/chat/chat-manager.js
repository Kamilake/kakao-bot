"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatManager = void 0;
const loco_packet_base_1 = require("../../packet/loco-packet-base");
const packet_delete_chat_1 = require("../../packet/packet-delete-chat");
const chat_1 = require("./chat");
const packet_sync_message_1 = require("../../packet/packet-sync-message");
const packet_multi_chatlog_1 = require("../../packet/packet-multi-chatlog");
const media_manager_1 = require("../media/media-manager");
const chat_builder_1 = require("./chat-builder");
const json_util_1 = require("../../util/json-util");
const packet_message_1 = require("../../packet/packet-message");
const chat_type_1 = require("./chat-type");
const packet_forward_1 = require("../../packet/packet-forward");
class ChatManager {
    constructor(client) {
        this.client = client;
        this.messageId = 0;
        this.mediaManager = new media_manager_1.MediaManager(client);
    }
    get Client() {
        return this.client;
    }
    get MediaManager() {
        return this.mediaManager;
    }
    get CurrentMessageId() {
        return this.messageId;
    }
    getNextMessageId() {
        return this.messageId++;
    }
    async getChatListFrom(channelId, sinceLogId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_multi_chatlog_1.PacketMultiChatlogReq([channelId], [sinceLogId]));
        let chatList = [];
        for (let chatLog of res.ChatlogList) {
            let chat = this.chatFromChatlog(chatLog);
            if (chat)
                chatList.push(chat);
        }
        return { status: res.StatusCode, result: chatList };
    }
    async getChatListBetween(channelId, startLogId, count, endLogId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_sync_message_1.PacketSyncMessageReq(channelId, startLogId, count, endLogId));
        let chatList = [];
        for (let chatLog of res.ChatList) {
            let chat = this.chatFromChatlog(chatLog);
            if (chat)
                chatList.push(chat);
        }
        return { status: res.StatusCode, result: chatList };
    }
    async chatFromWriteRes(res, text, extra) {
        if (res.Chatlog)
            return this.chatFromChatlog(res.Chatlog);
        return this.chatFromChatlog({
            logId: res.LogId,
            prevLogId: res.PrevLogId,
            senderId: this.client.ClientUser.Id,
            channelId: res.ChannelId,
            type: chat_type_1.ChatType.Text,
            text: text,
            sendTime: res.SendTime,
            rawAttachment: extra,
            messageId: res.MessageId
        });
    }
    async sendText(channel, ...textFormat) {
        let { text, extra } = chat_builder_1.ChatBuilder.buildMessage(...textFormat);
        return this.sendRaw(channel, chat_type_1.ChatType.Text, text, extra);
    }
    async forwardChat(channel, chat) {
        return this.forwardRaw(channel, chat.Type, chat.Text, chat.RawAttachment);
    }
    async sendRaw(channel, type, text, extra) {
        let extraText = json_util_1.JsonUtil.stringifyLoseless(extra);
        let res = await this.client.NetworkManager.requestPacketRes(new packet_message_1.PacketMessageWriteReq(this.client.ChatManager.getNextMessageId(), channel.Id, text, type, true, extraText));
        if (res.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
            return null;
        return this.chatFromWriteRes(res, text, extraText);
    }
    async forwardRaw(channel, type, text, extra) {
        let extraText = json_util_1.JsonUtil.stringifyLoseless(extra);
        let res = await this.client.NetworkManager.requestPacketRes(new packet_forward_1.PacketForwardReq(this.client.ChatManager.getNextMessageId(), channel.Id, text, type, true, extraText));
        if (res.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
            return null;
        return this.chatFromChatlog(res.Chatlog);
    }
    async sendMedia(channel, template) {
        return this.mediaManager.sendMedia(channel, template);
    }
    async sendTemplate(channel, template) {
        let sentType = template.getType();
        let text = template.getText();
        let extra = template.getExtra();
        let res = await this.client.NetworkManager.requestPacketRes(new packet_message_1.PacketMessageWriteReq(this.client.ChatManager.getNextMessageId(), channel.Id, text, sentType, true, extra));
        if (res.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
            return null;
        return this.chatFromWriteRes(res, text, extra);
    }
    chatFromChatlog(chatLog) {
        let channel = this.Client.ChannelManager.get(chatLog.channelId);
        if (!channel)
            return null;
        let sender = this.Client.UserManager.get(chatLog.senderId);
        const TypedChat = chat_1.TypeMap.getChatConstructor(chatLog.type);
        return new TypedChat(channel, sender, chatLog.messageId, chatLog.type, chatLog.logId, chatLog.prevLogId, chatLog.sendTime, chatLog.text, chatLog.rawAttachment);
    }
    async deleteChat(channelId, logId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_delete_chat_1.PacketDeleteChatReq(channelId, logId));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
}
exports.ChatManager = ChatManager;
//# sourceMappingURL=chat-manager.js.map