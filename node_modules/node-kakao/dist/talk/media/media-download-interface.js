"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaDataReceiver = exports.SecureDownloadSocket = exports.MediaDownloadInterface = void 0;
const stream_1 = require("stream");
const loco_interface_1 = require("../../loco/loco-interface");
const chunked_buffer_list_1 = require("../../network/chunk/chunked-buffer-list");
const loco_secure_socket_1 = require("../../network/loco-secure-socket");
const loco_encrypted_transformer_1 = require("../../network/stream/loco-encrypted-transformer");
const loco_packet_resolver_1 = require("../../network/stream/loco-packet-resolver");
const loco_packet_base_1 = require("../../packet/loco-packet-base");
const packet_down_1 = require("../../packet/media/packet-down");
const packet_mini_1 = require("../../packet/media/packet-mini");
const promise_ticket_1 = require("../../ticket/promise-ticket");
class MediaDownloadInterface extends loco_interface_1.LocoSecureCommandInterface {
    constructor(hostData, listener = null, configProvider) {
        super(hostData, listener, configProvider);
        this.downloading = false;
        this.size = -1;
        this.ticketObj = new promise_ticket_1.PromiseTicket();
        this.receiver = new MediaDataReceiver(this);
    }
    get Downloading() {
        return this.downloading;
    }
    get Size() {
        return this.size;
    }
    get DataReceiver() {
        return this.receiver;
    }
    createSocket(hostData) {
        return new SecureDownloadSocket(this.ConfigProvider.Configuration.locoPEMPublicKey, this, hostData.host, hostData.port, hostData.keepAlive);
    }
    downloadDone(buffer) {
        if (this.Connected)
            this.disconnect();
        this.ticketObj.resolve(buffer);
        this.downloading = false;
    }
    async download(clientUserId, key, channelId) {
        let config = this.ConfigProvider.Configuration;
        return this.requestDownload(new packet_down_1.PacketDownReq(key, 0, channelId, true, clientUserId, config.agent, config.version, config.netType, config.mccmnc));
    }
    async downloadThumbnail(clientUserId, key, channelId) {
        let config = this.ConfigProvider.Configuration;
        return this.requestDownload(new packet_mini_1.PacketMiniReq(key, 0, channelId, 0, 0, clientUserId, config.agent, config.version, config.netType, config.mccmnc));
    }
    async requestDownload(req) {
        if (this.downloading) {
            throw new Error(`Downloading already started`);
        }
        if (!this.Connected)
            await this.connect();
        let res = await this.requestPacketRes(req);
        if (res.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
            return null;
        this.size = res.Size;
        return this.ticketObj.createTicket();
    }
}
exports.MediaDownloadInterface = MediaDownloadInterface;
class SecureDownloadSocket extends loco_secure_socket_1.LocoSecureSocket {
    constructor(pubKey, receiver, host, port, keepAlive) {
        super(pubKey, receiver, host, port, keepAlive);
        this.downloader = receiver;
    }
    pipeTranformation(socket) {
        socket.pipe(new loco_encrypted_transformer_1.LocoEncryptedTransformer(this)).pipe(this.downloader.DataReceiver).pipe(new loco_packet_resolver_1.LocoPacketResolver(this));
    }
}
exports.SecureDownloadSocket = SecureDownloadSocket;
class MediaDataReceiver extends stream_1.Transform {
    constructor(downloader) {
        super();
        this.downloader = downloader;
        this.chunkList = new chunked_buffer_list_1.ChunkedBufferList();
    }
    get ChunkList() {
        return this.chunkList;
    }
    _destroy(error, callback) {
        this.chunkList.clear();
        super._destroy(error, callback);
    }
    _transform(chunk, encoding, callback) {
        if (this.downloader.Downloading) {
            this.chunkList.append(chunk);
            if (this.chunkList.TotalByteLength >= this.downloader.Size) {
                this.downloader.downloadDone(this.chunkList.toBuffer());
            }
        }
        else {
            this.push(chunk);
        }
        if (callback)
            callback();
    }
}
exports.MediaDataReceiver = MediaDataReceiver;
//# sourceMappingURL=media-download-interface.js.map