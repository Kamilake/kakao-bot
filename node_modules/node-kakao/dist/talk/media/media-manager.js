"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaManager = void 0;
const packet_ship_1 = require("../../packet/packet-ship");
const bson_1 = require("bson");
const Crypto = require("crypto");
const loco_packet_base_1 = require("../../packet/loco-packet-base");
const chat_attachment_1 = require("../chat/attachment/chat-attachment");
const packet_get_trailer_1 = require("../../packet/packet-get-trailer");
const packet_multi_ship_1 = require("../../packet/packet-multi-ship");
const chat_type_1 = require("../chat/chat-type");
class MediaManager {
    constructor(client) {
        this.client = client;
    }
    get Client() {
        return this.client;
    }
    get ClientUser() {
        return this.client.ClientUser;
    }
    get ChatManager() {
        return this.client.ChatManager;
    }
    get NetworkManager() {
        return this.client.NetworkManager;
    }
    async sendMedia(channel, template) {
        let res;
        if ('mediaList' in template) {
            let multiShipRes = await this.NetworkManager.requestPacketRes(new packet_multi_ship_1.PacketMultiShipReq(channel.Id, template.type, template.mediaList.map(item => bson_1.Long.fromNumber(item.data.length)), template.mediaList.map(item => this.createMediaHash(item.data)), template.mediaList.map(item => item.ext || '')));
            let reqList = [];
            let length = template.mediaList.length;
            if (length !== multiShipRes.KeyList.length)
                throw new Error(`Request size mismatch`);
            for (let i = 0; i < length; i++) {
                let media = template.mediaList[i];
                let key = multiShipRes.KeyList[i];
                let vHost = multiShipRes.VHostList[i];
                let port = multiShipRes.PortList[i];
                let uploadIface = this.NetworkManager.createUploadInterface({ host: vHost, port: port, keepAlive: true });
                reqList.push(uploadIface.uploadMulti(this.ClientUser.Id, key, template.type, media.data));
            }
            let completeList = await Promise.all(reqList);
            let errList = completeList.filter(completeRes => completeRes.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS);
            if (errList.length > 0)
                return null;
            return this.ChatManager.forwardRaw(channel, chat_type_1.ChatType.MultiPhoto, '', new chat_attachment_1.MultiPhotoAttachment(multiShipRes.KeyList, template.mediaList.map(item => bson_1.Long.fromNumber(item.data.length)), template.mediaList.map(item => item.width), template.mediaList.map(item => item.height), multiShipRes.MimeTypeList).toJsonAttachment());
        }
        else {
            let shipRes = await this.NetworkManager.requestPacketRes(new packet_ship_1.PacketShipReq(channel.Id, template.type, bson_1.Long.fromNumber(template.data.byteLength), this.createMediaHash(template.data), template.ext || ''));
            let uploadInterface = this.NetworkManager.createUploadInterface({ host: shipRes.VHost, port: shipRes.Port, keepAlive: true });
            res = await uploadInterface.upload(this.ClientUser.Id, shipRes.Key, channel.Id, template.type, template.name, template.data, 'width' in template ? template.width : 0, 'height' in template ? template.height : 0);
            if (res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS && res.Chatlog)
                return this.ChatManager.chatFromChatlog(res.Chatlog);
        }
        return null;
    }
    async requestThumbnail(channel, mediaAttachment) {
        if (!mediaAttachment.HasThumbnail)
            return null;
        let downloader = await this.createDownloaderFor(mediaAttachment);
        return downloader.downloadThumbnail(this.ClientUser.Id, mediaAttachment.KeyPath, channel.Id);
    }
    async requestMedia(channel, mediaAttachment) {
        let downloader = await this.createDownloaderFor(mediaAttachment);
        return downloader.download(this.ClientUser.Id, mediaAttachment.KeyPath, channel.Id);
    }
    async createDownloaderFor(mediaAttachment) {
        let trailerRes = await this.NetworkManager.requestPacketRes(new packet_get_trailer_1.PacketGetTrailerReq(mediaAttachment.KeyPath, mediaAttachment.RequiredMessageType));
        let downloadInterface = this.NetworkManager.createDownloadInterface({ host: trailerRes.VHost, port: trailerRes.Port, keepAlive: true });
        return downloadInterface;
    }
    createMediaHash(data) {
        let hash = Crypto.createHash('sha1');
        hash.update(data);
        return hash.digest().toString('hex').toUpperCase();
    }
}
exports.MediaManager = MediaManager;
//# sourceMappingURL=media-manager.js.map