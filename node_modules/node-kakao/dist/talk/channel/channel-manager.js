"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelManager = void 0;
const store_1 = require("../../store/store");
const bson_1 = require("bson");
const packet_create_channel_1 = require("../../packet/packet-create-channel");
const packet_channel_info_1 = require("../../packet/packet-channel-info");
const packet_leave_1 = require("../../packet/packet-leave");
const channel_type_1 = require("./channel-type");
const loco_packet_base_1 = require("../../packet/loco-packet-base");
const packet_chat_on_room_1 = require("../../packet/packet-chat-on-room");
const packet_noti_read_1 = require("../../packet/packet-noti-read");
const packet_update_channel_1 = require("../../packet/packet-update-channel");
const packet_set_meta_1 = require("../../packet/packet-set-meta");
const channel_meta_struct_1 = require("../struct/channel-meta-struct");
const packet_set_client_meta_1 = require("../../packet/packet-set-client-meta");
const packet_get_meta_1 = require("../../packet/packet-get-meta");
const packet_join_link_1 = require("../../packet/packet-join-link");
const open_link_type_1 = require("../open/open-link-type");
const packet_create_open_link_1 = require("../../packet/packet-create-open-link");
const managed_chat_channel_1 = require("../managed/managed-chat-channel");
const packet_add_member_1 = require("../../packet/packet-add-member");
const packet_kick_leave_1 = require("../../packet/packet-kick-leave");
const json_util_1 = require("../../util/json-util");
const packet_check_join_1 = require("../../packet/packet-check-join");
const packet_get_member_1 = require("../../packet/packet-get-member");
const packet_member_1 = require("../../packet/packet-member");
class ChannelManager extends store_1.IdStore {
    constructor(client) {
        super();
        this.client = client;
    }
    get Client() {
        return this.client;
    }
    getChannelList() {
        return Array.from(super.values());
    }
    findOpenChatChannel(linkId) {
        let channels = this.values();
        for (let channel of channels) {
            if (!channel.isOpenChat())
                break;
            if (linkId.equals(channel.LinkId))
                return channel;
        }
        return null;
    }
    async addWithChannelData(id, channelData) {
        let channel;
        switch (channelData.type) {
            case channel_type_1.ChannelType.OPENCHAT_DIRECT:
            case channel_type_1.ChannelType.OPENCHAT_GROUP: {
                let link = await this.client.OpenLinkManager.get(channelData.linkId);
                if (!link)
                    throw new Error(`Invalid OpenLink at Channel ${id}`);
                channel = new managed_chat_channel_1.ManagedOpenChatChannel(this, id, channelData, channelData.linkId, channelData.openToken, link);
                break;
            }
            case channel_type_1.ChannelType.SELFCHAT:
                channel = new managed_chat_channel_1.ManagedMemoChatChannel(this, id, channelData);
                break;
            case channel_type_1.ChannelType.GROUP:
            case channel_type_1.ChannelType.DIRECT:
                channel = new managed_chat_channel_1.ManagedNormalChatChannel(this, id, channelData);
                break;
            case channel_type_1.ChannelType.PLUSCHAT:
            default:
                channel = new managed_chat_channel_1.ManagedChatChannel(this, id, channelData);
                break;
        }
        let memberList = await this.requestMemberList(channel.Id);
        if (memberList) {
            this.updateUserInfoList(channel, memberList);
        }
        await this.sendChatOn(channel);
        this.set(id, channel);
        return channel;
    }
    async addChannel(id) {
        let info = await this.requestChannelInfo(id);
        if (!info)
            return null;
        return this.addWithChannelInfo(id, info);
    }
    async addWithChannelInfo(id, channelInfo) {
        let channel = await this.addWithChannelData(id, channelInfo);
        this.initChannelInfo(channel, channelInfo);
        return channel;
    }
    initChannelInfo(channel, channelInfo) {
        channel.updateData(channelInfo);
        if (channelInfo.metadata)
            channel.updateClientMeta(channelInfo.metadata);
        if (channelInfo.channelMetaList)
            channel.updateMetaList(channelInfo.channelMetaList);
        if (channelInfo.lastChatLog)
            channel.updateLastChat(this.client.ChatManager.chatFromChatlog(channelInfo.lastChatLog));
        if (channelInfo.displayMemberList)
            channel.updateDisplayUserInfoList(channelInfo.displayMemberList.map(this.getDisplayUserInfoFromStruct.bind(this)));
    }
    updateUserInfoList(channel, memberList, openProfile) {
        if (!channel.isOpenChat()) {
            let normal = channel;
            normal.updateMemberList(memberList);
        }
        else {
            let open = channel;
            if (openProfile)
                open.updateOpenMember(openProfile);
            open.updateOpenMemberList(memberList);
        }
    }
    getDisplayUserInfoFromStruct(memberStruct) {
        return new managed_chat_channel_1.ManagedDisplayUserInfo(this.client.UserManager.get(memberStruct.userId), memberStruct);
    }
    async createMemoChannel() {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_create_channel_1.PacketCreateChannelReq([], '', '', true));
        if (this.has(res.ChannelId))
            return { status: loco_packet_base_1.StatusCode.SUCCESS, result: this.get(res.ChannelId) };
        if (!res.ChatInfo)
            return { status: res.StatusCode };
        let channel = await this.addWithChannelInfo(res.ChannelId, res.ChatInfo);
        return { status: res.StatusCode, result: channel };
    }
    async createChannel(users, nickname = '', profileURL = '') {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_create_channel_1.PacketCreateChannelReq(users.map((user) => user.Id), nickname, profileURL));
        if (this.has(res.ChannelId))
            return { status: loco_packet_base_1.StatusCode.SUCCESS, result: this.get(res.ChannelId) };
        if (!res.ChatInfo)
            return { status: res.StatusCode };
        let channel = await this.addWithChannelInfo(res.ChannelId, res.ChatInfo);
        return { status: res.StatusCode, result: channel };
    }
    async createOpenChannel(template) {
        let packet = new packet_create_open_link_1.PacketCreateOpenLinkReq(template.linkName, template.linkCoverPath, open_link_type_1.OpenLinkType.CHANNEL, template.description, template.profileContent || null, template.allowAnonProfile, template.canSearchLink, bson_1.Long.fromNumber(Date.now() / 1000), true, 0, template.clientProfile.type, template.clientProfile.anonNickname, template.clientProfile.anonProfilePath, template.clientProfile.profileLinkId, template.maxUserLimit);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        if (!res.ChatInfo || !res.OpenLink)
            return { status: res.StatusCode };
        res.ChatInfo.linkId = res.OpenLink.linkId;
        res.ChatInfo.openToken = res.OpenLink.openToken;
        return { status: res.StatusCode, result: await this.addWithChannelInfo(res.ChatInfo.channelId, res.ChatInfo) };
    }
    async joinOpenChannel(linkId, profileTemplate, passcode = '') {
        let joinToken = '';
        if (passcode) {
            let checkPacket = new packet_check_join_1.PacketCheckJoinReq(linkId, passcode);
            let checkRes = await this.client.NetworkManager.requestPacketRes(checkPacket);
            if (checkRes.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
                return { status: checkRes.StatusCode };
            joinToken = checkRes.Token;
        }
        let joinPacket = new packet_join_link_1.PacketJoinLinkReq(linkId, 'EW:', joinToken, profileTemplate.type, profileTemplate.anonNickname, profileTemplate.anonProfilePath, profileTemplate.profileLinkId);
        let res = await this.client.NetworkManager.requestPacketRes(joinPacket);
        if (!res.ChatInfo || !res.LinkInfo)
            return { status: res.StatusCode };
        res.ChatInfo.linkId = res.LinkInfo.linkId;
        res.ChatInfo.openToken = res.LinkInfo.openToken;
        return { status: res.StatusCode, result: await this.addWithChannelInfo(res.ChatInfo.channelId, res.ChatInfo) };
    }
    async requestChannelInfo(channelId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_channel_info_1.PacketChannelInfoReq(channelId));
        if (res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS || res.StatusCode === loco_packet_base_1.StatusCode.INVALID_CHATROOM_OPERATION) {
            return res.ChatInfo;
        }
        else {
            return null;
        }
    }
    async requestMemberList(channelId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_get_member_1.PacketGetMemberReq(channelId));
        if (res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS) {
            return res.MemberList;
        }
        else {
            return null;
        }
    }
    async requestDetailedMemberList(channelId, memberIdList) {
        if (!memberIdList) {
            let simplfiedList = await this.requestMemberList(channelId);
            if (!simplfiedList)
                return null;
            memberIdList = simplfiedList.map(member => member.userId);
        }
        let res = await this.client.NetworkManager.requestPacketRes(new packet_member_1.PacketMemberReq(channelId, memberIdList));
        if (res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS) {
            return res.MemberList;
        }
        else {
            return null;
        }
    }
    async sendChatOn(channel) {
        let token = channel.LastChat ? channel.LastChat.LogId : bson_1.Long.ZERO;
        let openToken;
        if (channel.isOpenChat())
            openToken = channel.OpenToken;
        let res = await this.client.NetworkManager.requestPacketRes(new packet_chat_on_room_1.PacketChatOnRoomReq(channel.Id, token, openToken));
        if (res.MemberList) {
            this.updateUserInfoList(channel, res.MemberList, res.ClientOpenProfile);
        }
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async leave(channel, block = false) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_leave_1.PacketLeaveReq(channel.Id, block));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async leaveKicked(channel) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_kick_leave_1.PacketKickLeaveReq(channel.LinkId, channel.Id));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async markRead(channel, lastWatermark) {
        if (channel.isOpenChat()) {
            await this.client.NetworkManager.sendPacket(new packet_noti_read_1.PacketMessageNotiReadReq(channel.Id, lastWatermark, channel.LinkId));
        }
        else {
            await this.client.NetworkManager.sendPacket(new packet_noti_read_1.PacketMessageNotiReadReq(channel.Id, lastWatermark));
        }
    }
    async inviteUser(channel, user) {
        return this.inviteUserId(channel, user.Id);
    }
    async inviteUserId(channel, userId) {
        return this.inviteUserIdList(channel, [userId]);
    }
    async inviteUserList(channel, userList) {
        return this.inviteUserIdList(channel, userList.map(user => user.Id));
    }
    async inviteUserIdList(channel, userIdList) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_add_member_1.PacketAddMemberReq(channel.Id, userIdList));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async updateChannelSettings(channel, settings) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_update_channel_1.PacketUpdateChannelReq(channel.Id, settings.pushAlert));
        if (res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS)
            channel.updateChannelSettings(settings);
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async requestChannelMeta(channel, type) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_get_meta_1.PacketGetMetaReq(channel.Id, [type]));
        return { status: res.StatusCode, result: res.MetaList[0] };
    }
    async requestChannelMetaList(channel) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_get_meta_1.PacketGetMetaListReq([channel.Id]));
        return { status: res.StatusCode, result: res.MetaSetList[0] && res.MetaSetList[0].metaList || null };
    }
    async updateChannelMeta(channel, type, content) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_set_meta_1.PacketSetMetaReq(channel.Id, type, content));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async updateChannelClientMeta(channel, type, content) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_set_client_meta_1.PacketSetClientMetaReq(channel.Id, type, content));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async setTitleMeta(channel, title) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.TITLE, title);
    }
    async setNoticeMeta(channel, notice) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.NOTICE, notice);
    }
    async setPrivilegeMeta(channel, content) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.PRIVILEGE, json_util_1.JsonUtil.stringifyLoseless(content));
    }
    async setProfileMeta(channel, content) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.PROFILE, json_util_1.JsonUtil.stringifyLoseless(content));
    }
    async setTvMeta(channel, content) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.TV, json_util_1.JsonUtil.stringifyLoseless(content));
    }
    async setTvLiveMeta(channel, content) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.TV_LIVE, json_util_1.JsonUtil.stringifyLoseless(content));
    }
    async setLiveTalkCountMeta(channel, content) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.LIVE_TALK_COUNT, json_util_1.JsonUtil.stringifyLoseless(content));
    }
    async setGroupMeta(channel, content) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.GROUP, json_util_1.JsonUtil.stringifyLoseless(content));
    }
    async setBotMeta(channel, content) {
        return this.updateChannelMeta(channel, channel_meta_struct_1.ChannelMetaType.BOT, json_util_1.JsonUtil.stringifyLoseless(content));
    }
    removeChannel(channelId) {
        if (!this.has(channelId))
            return false;
        this.delete(channelId);
        return true;
    }
    async initWithChannelData(channelData) {
        let channel = await this.addWithChannelData(channelData.channelId, channelData);
        let info = await this.requestChannelInfo(channel.Id);
        if (info)
            this.initChannelInfo(channel, info);
        return channel;
    }
    async initializeLoginData(chatDataList) {
        this.clear();
        return Promise.all(chatDataList.map(this.initWithChannelData.bind(this)));
    }
}
exports.ChannelManager = ChannelManager;
ChannelManager.INFO_UPDATE_INTERVAL = 300000;
//# sourceMappingURL=channel-manager.js.map