"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenLinkManager = void 0;
const packet_join_info_1 = require("../../packet/packet-join-info");
const bson_1 = require("bson");
const packet_info_link_1 = require("../../packet/packet-info-link");
const packet_sync_link_1 = require("../../packet/packet-sync-link");
const store_1 = require("../../store/store");
const loco_packet_base_1 = require("../../packet/loco-packet-base");
const packet_kick_member_1 = require("../../packet/packet-kick-member");
const packet_delete_link_1 = require("../../packet/packet-delete-link");
const packet_rewrite_1 = require("../../packet/packet-rewrite");
const feed_type_1 = require("../feed/feed-type");
const packet_set_mem_type_1 = require("../../packet/packet-set-mem-type");
const packet_update_link_profile_1 = require("../../packet/packet-update-link-profile");
const open_link_type_1 = require("./open-link-type");
const packet_create_open_link_1 = require("../../packet/packet-create-open-link");
const packet_update_link_1 = require("../../packet/packet-update-link");
const managed_open_link_1 = require("../managed/managed-open-link");
const packet_kick_list_sync_1 = require("../../packet/packet-kick-list-sync");
const packet_kick_list_del_item_1 = require("../../packet/packet-kick-list-del-item");
const packet_reaction_count_1 = require("../../packet/packet-reaction-count");
const packet_react_1 = require("../../packet/packet-react");
class OpenLinkManager extends store_1.AsyncIdInstanceStore {
    constructor(client) {
        super();
        this.client = client;
        this.clientLinkIdList = [];
    }
    get Client() {
        return this.client;
    }
    get Interface() {
        return this.client.NetworkManager;
    }
    get ClientUser() {
        return this.client.ClientUser;
    }
    get ClientLinkList() {
        return this.clientLinkIdList.map(strId => bson_1.Long.fromString(strId));
    }
    isClientLink(id) {
        return this.clientLinkIdList.includes(id.toString());
    }
    async getFromURL(openLinkURL) {
        let res = await this.Interface.requestPacketRes(new packet_join_info_1.PacketJoinInfoReq(openLinkURL, 'EW'));
        if (res.OpenLink)
            return this.getWithLinkStruct(res.OpenLink.linkId, res.OpenLink);
        return null;
    }
    async requestLinkFromIdList(linkIdList) {
        let res = await this.Interface.requestPacketRes(new packet_info_link_1.PacketInfoLinkReq(linkIdList));
        return res.LinkList;
    }
    async requestLinkFromId(linkId) {
        let res = await this.Interface.requestPacketRes(new packet_info_link_1.PacketInfoLinkReq([linkId]));
        return res.LinkList[0] || null;
    }
    async requestLinkFromURL(openLinkURL) {
        let res = await this.Interface.requestPacketRes(new packet_join_info_1.PacketJoinInfoReq(openLinkURL, 'EW'));
        return res.OpenLink || null;
    }
    getWithLinkStruct(linkId, linkStruct) {
        if (this.has(linkId)) {
            let link = this.getFromMap(linkId);
            link.updateStruct(linkStruct);
            return link;
        }
        let link = this.createWithLinkStruct(linkId, linkStruct);
        this.set(linkId, link);
        return link;
    }
    async updateInfo(link) {
        let linkStruct = await this.requestLinkFromId(link.LinkId);
        if (linkStruct)
            link.updateStruct(linkStruct);
        return link;
    }
    createWithLinkStruct(linkId, linkStruct) {
        return new managed_open_link_1.ManagedOpenLink(this, linkId, linkStruct.openToken, linkStruct);
    }
    getFromKickedStruct(kickedMemberStruct) {
        return new managed_open_link_1.ManagedOpenKickedUserInfo(this, kickedMemberStruct);
    }
    async createInstanceFor(key) {
        let linkStruct = await this.requestLinkFromId(key);
        if (!linkStruct)
            return null;
        return this.createWithLinkStruct(key, linkStruct);
    }
    async requestClientProfile() {
        let openChatToken = this.ClientUser.MainOpenToken;
        let res = await this.client.NetworkManager.requestPacketRes(new packet_sync_link_1.PacketSyncLinkReq(openChatToken));
        return { status: res.StatusCode, result: res.LinkList.map((linkStruct) => this.getWithLinkStruct(linkStruct.linkId, linkStruct)) };
    }
    async initOpenSession() {
        this.clear();
        this.clientLinkIdList = [];
        let list = await this.requestClientProfile();
        if (list.status !== loco_packet_base_1.StatusCode.SUCCESS || !list.result)
            return;
        for (let profile of list.result) {
            this.clientLinkIdList.push(profile.LinkId.toString());
        }
    }
    async kickMember(channel, userId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_kick_member_1.PacketKickMemberReq(channel.LinkId, channel.Id, userId));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async deleteLink(linkId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_delete_link_1.PacketDeleteLinkReq(linkId));
        this.delete(linkId);
        let strLinkId = linkId.toString();
        this.clientLinkIdList = this.clientLinkIdList.filter(strKey => strKey !== strLinkId);
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async handOverHost(channel, newHostUserId) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_set_mem_type_1.PacketSetMemTypeReq(channel.LinkId, channel.Id, [newHostUserId, channel.Client.ClientUser.Id], [open_link_type_1.OpenMemberType.OWNER, open_link_type_1.OpenMemberType.NONE]));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async hideChat(channel, logId, type) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_rewrite_1.PacketRewriteReq(channel.LinkId, channel.Id, logId, type, feed_type_1.FeedType.OPENLINK_REWRITE_FEED));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async setOpenMemberType(channel, userId, type) {
        let res = await this.client.NetworkManager.requestPacketRes(new packet_set_mem_type_1.PacketSetMemTypeReq(channel.LinkId, channel.Id, [userId], [type]));
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async changeProfile(channel, profile) {
        let packet = new packet_update_link_profile_1.PacketUpdateLinkProfileReq(channel.LinkId, profile.type, profile.anonNickname, profile.anonProfilePath, profile.profileLinkId);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async createOpenProfile(template) {
        const packet = new packet_create_open_link_1.PacketCreateOpenLinkReq(template.linkName, template.linkCoverPath, open_link_type_1.OpenLinkType.PROFILE, template.description, template.profileContent || null, template.allowAnonProfile, template.canSearchLink, bson_1.Long.fromNumber(Date.now() / 1000), true, template.maxChannelLimit, template.clientProfile.type, template.clientProfile.anonNickname, template.clientProfile.anonProfilePath, template.clientProfile.profileLinkId, template.maxUserLimit);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        return { status: res.StatusCode, result: res.OpenLink && this.getWithLinkStruct(res.OpenLink.linkId, res.OpenLink) || null };
    }
    async updateOpenLink(linkId, settings) {
        const packet = new packet_update_link_1.PacketUpdateOpenLinkReq(linkId, settings.linkName, settings.linkCoverPath, settings.maxUserLimit, settings.maxChannelLimit, settings.passcode, settings.description, settings.canSearchLink, true, true);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        return res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS;
    }
    async deleteFromKickList(linkId, kickedInfo) {
        return this.deleteFromKickListId(linkId, kickedInfo.KickedChannelId, kickedInfo.Id);
    }
    async deleteFromKickListId(linkId, channelId, userId) {
        let packet = new packet_kick_list_del_item_1.PacketKickListDelItemReq(linkId, channelId, userId);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
    async requestKickList(linkId) {
        let packet = new packet_kick_list_sync_1.PacketKickListSyncReq(linkId);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        return { status: res.StatusCode, result: res.KickedMemberList.map(this.getFromKickedStruct.bind(this)) };
    }
    async requestReactionInfo(linkId) {
        let packet = new packet_reaction_count_1.PacketReactionCountReq(linkId);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        return { status: res.StatusCode, result: { reactionCount: res.ReactionCount.toNumber(), reactionType: res.ReactType } };
    }
    async setLinkReacted(linkId, reactionType) {
        let packet = new packet_react_1.PacketReactReq(linkId, reactionType);
        let res = await this.client.NetworkManager.requestPacketRes(packet);
        return { status: res.StatusCode, result: res.StatusCode === loco_packet_base_1.StatusCode.SUCCESS };
    }
}
exports.OpenLinkManager = OpenLinkManager;
//# sourceMappingURL=open-link-manager.js.map