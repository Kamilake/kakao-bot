"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PacketForwardRes = exports.PacketForwardReq = void 0;
const loco_bson_packet_1 = require("./loco-bson-packet");
const chat_type_1 = require("../talk/chat/chat-type");
const bson_1 = require("bson");
const chatlog_struct_1 = require("../talk/struct/chatlog-struct");
const json_proxy_mapper_1 = require("json-proxy-mapper");
class PacketForwardReq extends loco_bson_packet_1.LocoBsonRequestPacket {
    constructor(MessageId = 0, ChannelId = bson_1.Long.ZERO, Text = '', Type = chat_type_1.ChatType.Text, NoSeen = false, Extra = '') {
        super();
        this.MessageId = MessageId;
        this.ChannelId = ChannelId;
        this.Text = Text;
        this.Type = Type;
        this.NoSeen = NoSeen;
        this.Extra = Extra;
    }
    get PacketName() {
        return 'FORWARD';
    }
    toBodyJson() {
        return {
            'chatId': this.ChannelId,
            'msgId': this.MessageId,
            'msg': this.Text,
            'type': this.Type,
            'noSeen': this.NoSeen,
            'extra': this.Extra
        };
    }
}
exports.PacketForwardReq = PacketForwardReq;
class PacketForwardRes extends loco_bson_packet_1.LocoBsonResponsePacket {
    constructor(status, Chatlog) {
        super(status);
        this.Chatlog = Chatlog;
    }
    get PacketName() {
        return 'FORWARD';
    }
    readBodyJson(rawBody) {
        if (rawBody['chatLog']) {
            this.Chatlog = json_proxy_mapper_1.Serializer.deserialize(rawBody['chatLog'], chatlog_struct_1.ChatlogStruct.MAPPER);
        }
    }
}
exports.PacketForwardRes = PacketForwardRes;
//# sourceMappingURL=packet-forward.js.map