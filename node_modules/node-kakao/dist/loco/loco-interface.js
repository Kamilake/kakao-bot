"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocoSecureCommandInterface = exports.LocoTLSCommandInterface = exports.LocoCommandInterface = void 0;
const loco_packet_list_1 = require("../packet/loco-packet-list");
const loco_secure_socket_1 = require("../network/loco-secure-socket");
const loco_tls_socket_1 = require("../network/loco-tls-socket");
class LocoCommandInterface {
    constructor(hostData, listener = null, configProvider) {
        this.listener = listener;
        this.configProvider = configProvider;
        this.packetCount = 0;
        this.packetMap = new Map();
        this.socket = this.createSocket(hostData);
    }
    get ConfigProvider() {
        return this.configProvider;
    }
    get Socket() {
        return this.socket;
    }
    get Connected() {
        return this.socket.Connected;
    }
    async connect() {
        if (this.Connected)
            return false;
        return this.socket.connect();
    }
    disconnect() {
        return this.socket.disconnect();
    }
    get CurrentPacketId() {
        return this.packetCount;
    }
    set CurrentPacketId(value) {
        this.packetCount = value;
    }
    getNextPacketId() {
        return ++this.packetCount;
    }
    async sendPacket(packet) {
        if (!this.Connected) {
            return false;
        }
        let packetId = this.getNextPacketId();
        this.packetMap.set(packetId, packet);
        if (!loco_packet_list_1.LocoPacketList.hasReqPacket(packet.PacketName)) {
            throw new Error(`Tried to send invalid packet ${packet.PacketName}`);
        }
        let header = {
            packetId: packetId,
            statusCode: 0,
            packetName: packet.PacketName,
            bodyType: 0,
            bodySize: 0
        };
        let bodyBuffer = packet.writeBody();
        header.bodySize = bodyBuffer.byteLength;
        let res = await this.socket.sendPacket(header, bodyBuffer);
        if (this.listener)
            this.listener.packetSent(packetId, packet);
        return res;
    }
    async requestPacketRes(packet) {
        let ticket = packet.submitResponseTicket();
        if (!(await this.sendPacket(packet))) {
            throw new Error(`Request for ${packet.PacketName} failed`);
        }
        return ticket;
    }
    responseReceived(header, data) {
        try {
            let packetId = header.packetId;
            let packet = this.structToPacket(header, data);
            let reqPacket = this.packetMap.get(packetId);
            if (reqPacket) {
                this.packetMap.delete(packetId);
                reqPacket.onResponse(packet);
            }
            if (this.listener)
                this.listener.packetReceived(packetId, packet, reqPacket);
            return packet;
        }
        catch (e) {
            throw new Error(`Error while processing packet#${header.packetId} ${header.packetName}: ${e}`);
        }
    }
    structToPacket(header, bodyBuffer, offset = 0) {
        let bodyBuf = bodyBuffer.slice(offset, offset + header.bodySize);
        let packet;
        if (loco_packet_list_1.LocoPacketList.hasResPacket(header.packetName)) {
            packet = loco_packet_list_1.LocoPacketList.getResPacketByName(header.packetName, header.statusCode);
        }
        else {
            if (loco_packet_list_1.LocoPacketList.hasResBodyType(header.bodyType)) {
                packet = loco_packet_list_1.LocoPacketList.getDefaultResPacket(header.bodyType, header.packetName, header.statusCode);
            }
            else {
                throw new Error(`Invalid packet type: ${header.bodyType}`);
            }
        }
        packet.readBody(bodyBuf);
        return packet;
    }
    onError(err) {
        var _a;
        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onError(err);
    }
    disconnected() {
        var _a;
        this.packetMap.clear();
        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.disconnected();
    }
}
exports.LocoCommandInterface = LocoCommandInterface;
class LocoTLSCommandInterface extends LocoCommandInterface {
    createSocket(hostData) {
        return new loco_tls_socket_1.LocoTLSSocket(this, hostData.host, hostData.port, hostData.keepAlive);
    }
}
exports.LocoTLSCommandInterface = LocoTLSCommandInterface;
class LocoSecureCommandInterface extends LocoCommandInterface {
    createSocket(hostData) {
        return new loco_secure_socket_1.LocoSecureSocket(this.ConfigProvider.Configuration.locoPEMPublicKey, this, hostData.host, hostData.port, hostData.keepAlive);
    }
}
exports.LocoSecureCommandInterface = LocoSecureCommandInterface;
//# sourceMappingURL=loco-interface.js.map