"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocoBasicSocket = void 0;
const loco_packet_resolver_1 = require("./stream/loco-packet-resolver");
class LocoBasicSocket {
    constructor(receiver, host, port, keepAlive = false) {
        this.receiver = receiver;
        this.host = host;
        this.port = port;
        this.keepAlive = keepAlive;
        this.socket = null;
        this.connected = false;
    }
    get Host() {
        return this.host;
    }
    get Port() {
        return this.port;
    }
    get Socket() {
        return this.socket;
    }
    get Connected() {
        return this.connected;
    }
    get KeepAlive() {
        return this.keepAlive;
    }
    set KeepAlive(flag) {
        this.keepAlive = flag;
    }
    async connect() {
        if (this.connected) {
            return false;
        }
        await new Promise((resolve, reject) => {
            this.socket = this.createSocketConnection(this.host, this.port, resolve);
            this.pipeTranformation(this.socket);
            this.socket.on('error', this.connectionError.bind(this));
            this.socket.on('end', this.connectionEnded.bind(this));
            this.onConnect();
        });
        this.connected = true;
        this.onConnected();
        return true;
    }
    pipeTranformation(socket) {
        socket.pipe(new loco_packet_resolver_1.LocoPacketResolver(this));
    }
    disconnect() {
        if (!this.connected) {
            return false;
        }
        this.onDisconnect();
        this.socket.destroy();
        this.socket = null;
        this.connected = false;
        this.onDisconnected();
        return true;
    }
    onDisconnect() {
    }
    onDisconnected() {
        this.receiver.disconnected();
    }
    connectionError(e) {
        this.onError(e);
        this.disconnect();
    }
    connectionEnded(buffer) {
        this.onEnd(buffer);
        this.disconnect();
    }
    dataReceived(header, data) {
        try {
            this.receiver.responseReceived(header, data);
            if (!this.keepAlive) {
                this.disconnect();
            }
        }
        catch (err) {
            this.onError(err);
        }
    }
    transformBuffer(data) {
        return data;
    }
    async sendPacket(header, bodyBuffer) {
        if (!this.connected)
            return false;
        return this.sendBuffer(this.toPacketBuffer(header, bodyBuffer));
    }
    async sendBuffer(buffer) {
        if (!this.connected) {
            return false;
        }
        return new Promise((resolve, reject) => this.socket.write(this.transformBuffer(buffer), (e) => {
            if (e) {
                reject(e);
            }
            else {
                resolve(true);
            }
        }));
    }
    toPacketBuffer(header, bodyBuffer, buffer, offset = 0) {
        header.bodySize = bodyBuffer.byteLength;
        let size = 22 + header.bodySize;
        if (buffer && buffer.length < offset + size) {
            throw new Error(`Provided buffer is smaller than required. Size: ${buffer.length}, Required: ${offset + size}`);
        }
        else {
            buffer = Buffer.allocUnsafe(size + offset);
        }
        let headerBuffer = this.createHeaderBuffer(header);
        if (!Buffer.isBuffer(bodyBuffer)) {
            bodyBuffer = Buffer.from(bodyBuffer);
        }
        headerBuffer.copy(buffer, offset, 0);
        bodyBuffer.copy(buffer, offset + 22, 0);
        return buffer;
    }
    createHeaderBuffer(header) {
        let buffer = Buffer.allocUnsafe(22);
        buffer.writeUInt32LE(header.packetId, 0);
        buffer.writeUInt16LE(header.statusCode, 4);
        let written = buffer.write(header.packetName, 6, 'utf8');
        buffer.fill(0, 6 + written, 17);
        buffer.writeInt8(header.bodyType, 17);
        buffer.writeUInt32LE(header.bodySize, 18);
        return buffer;
    }
    onError(err) {
        this.receiver.onError(err);
    }
}
exports.LocoBasicSocket = LocoBasicSocket;
//# sourceMappingURL=loco-socket.js.map