"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainInterface = exports.CheckinData = exports.BookingData = exports.NetworkManager = void 0;
const packet_handler_1 = require("./packet-handler");
const loco_interface_1 = require("../loco/loco-interface");
const loco_packet_base_1 = require("../packet/loco-packet-base");
const packet_login_1 = require("../packet/packet-login");
const packet_ping_1 = require("../packet/packet-ping");
const packet_check_in_1 = require("../packet/checkin/packet-check-in");
const packet_get_conf_1 = require("../packet/booking/packet-get-conf");
const packet_buy_call_server_1 = require("../packet/checkin/packet-buy-call-server");
const media_upload_interface_1 = require("../talk/media/media-upload-interface");
const media_download_interface_1 = require("../talk/media/media-download-interface");
class NetworkManager {
    constructor(client, configProvider) {
        this.client = client;
        this.configProvider = configProvider;
        this.cachedBookingData = null;
        this.cachedCheckinData = null;
        this.lastCheckinReq = -1;
        this.mainInterface = null;
        this.handler = this.createPacketHandler();
    }
    get Client() {
        return this.client;
    }
    get Connected() {
        return this.mainInterface && this.mainInterface.Connected || false;
    }
    get Logon() {
        return this.mainInterface && this.mainInterface.Logon || false;
    }
    get Handler() {
        return this.handler;
    }
    set Handler(handler) {
        this.handler = handler;
    }
    async connect() {
        return this.mainInterface && this.mainInterface.connect() || false;
    }
    disconnect() {
        return this.mainInterface && this.mainInterface.disconnect() || false;
    }
    async sendPacket(packet) {
        return this.mainInterface && await this.mainInterface.sendPacket(packet) || false;
    }
    async requestPacketRes(packet) {
        if (!this.mainInterface) {
            throw new Error("Not Connected to loco");
        }
        return this.mainInterface.requestPacketRes(packet);
    }
    createBookingInterface(hostInfo, listener = this, configProvider = this.configProvider) {
        return new loco_interface_1.LocoTLSCommandInterface(hostInfo, listener, configProvider);
    }
    createCheckinInterface(hostInfo, listener = this, configProvider = this.configProvider) {
        return new loco_interface_1.LocoSecureCommandInterface(hostInfo, listener, configProvider);
    }
    createMainInterface(hostInfo, listener = this, configProvider = this.configProvider) {
        return new MainInterface(hostInfo, listener, configProvider);
    }
    createUploadInterface(hostInfo, listener = this, configProvider = this.configProvider) {
        return new media_upload_interface_1.MediaUploadInterface(hostInfo, listener, configProvider);
    }
    createDownloadInterface(hostInfo, listener = this, configProvider = this.configProvider) {
        return new media_download_interface_1.MediaDownloadInterface(hostInfo, listener, configProvider);
    }
    async requestCheckinData(userId) {
        let config = this.configProvider.Configuration;
        let res = await this.requestCheckinRes(new packet_check_in_1.PacketCheckInReq(userId, config.agent, config.netType, config.appVersion, config.mccmnc, config.language, config.countryIso, config.subDevice));
        if (res.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
            throw res.StatusCode;
        return new CheckinData({
            host: res.Host,
            port: res.Port,
            keepAlive: true
        }, res.CacheExpire);
    }
    async requestCallServerData(userId) {
        let config = this.configProvider.Configuration;
        let res = await this.requestCheckinRes(new packet_buy_call_server_1.PacketBuyCallServerReq(userId, config.agent, config.netType, config.appVersion, config.mccmnc, config.countryIso));
        if (res.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
            throw res.StatusCode;
        return res;
    }
    async requestBookingData() {
        let config = this.configProvider.Configuration;
        let res = await this.requestBookingRes(new packet_get_conf_1.PacketGetConfReq(config.mccmnc, config.agent, config.deviceModel));
        return new BookingData({
            host: res.HostList[0],
            port: res.PortList[0],
            keepAlive: false
        });
    }
    async requestBookingRes(packet) {
        let config = this.configProvider.Configuration;
        let bookingInterface = this.createBookingInterface({
            host: config.locoBookingURL,
            port: config.locoBookingPort,
            keepAlive: false
        });
        if (!(await bookingInterface.connect())) {
            throw new Error('Cannot contact to booking server');
        }
        return bookingInterface.requestPacketRes(packet);
    }
    async requestCheckinRes(packet) {
        let checkinInterface = this.createCheckinInterface((await this.getBookingData()).CheckinHost);
        if (!(await checkinInterface.connect())) {
            throw new Error('Cannot contact to checkin server');
        }
        return checkinInterface.requestPacketRes(packet);
    }
    async getBookingData(forceRecache = false) {
        if (!this.cachedBookingData || forceRecache) {
            try {
                this.cachedBookingData = await this.requestBookingData();
            }
            catch (statusCode) {
                throw new Error(`Booking failed. code: ${statusCode}`);
            }
        }
        return this.cachedBookingData;
    }
    async getCheckinData(userId, forceRecache = false) {
        if (!this.cachedCheckinData || this.cachedCheckinData.expireTime + this.lastCheckinReq < Date.now() || forceRecache) {
            try {
                this.cachedCheckinData = await this.requestCheckinData(userId);
                this.lastCheckinReq = Date.now();
            }
            catch (statusCode) {
                throw new Error(`Checkin failed. code: ${statusCode}`);
            }
        }
        return this.cachedCheckinData;
    }
    createPacketHandler() {
        return new packet_handler_1.TalkPacketHandler(this);
    }
    async locoLogin(deviceUUID, userId, accessToken) {
        if (this.Logon) {
            throw new Error('Already logon to loco');
        }
        let checkinData = await this.getCheckinData(userId);
        this.mainInterface = this.createMainInterface(checkinData.LocoHost);
        if (!(await this.mainInterface.connect())) {
            throw new Error(`Loco Login failed`);
        }
        let res = await this.mainInterface.login(deviceUUID, accessToken);
        return res;
    }
    packetSent(packetId, packet) {
        this.Handler.onRequest(packetId, packet);
    }
    packetReceived(packetId, packet, reqPacket) {
        this.Handler.onResponse(packetId, packet, reqPacket);
    }
    onError(err) {
        this.Client.emit('error', err);
    }
    disconnected() {
        this.Handler.onDisconnected();
    }
}
exports.NetworkManager = NetworkManager;
NetworkManager.PING_INTERVAL = 600000;
class BookingData {
    constructor(CheckinHost) {
        this.CheckinHost = CheckinHost;
    }
}
exports.BookingData = BookingData;
class CheckinData {
    constructor(LocoHost, expireTime) {
        this.LocoHost = LocoHost;
        this.expireTime = expireTime;
    }
}
exports.CheckinData = CheckinData;
class MainInterface extends loco_interface_1.LocoSecureCommandInterface {
    constructor(hostData, listener, configProvider) {
        super(hostData, listener, configProvider);
        this.locoLogon = false;
        this.pingSchedulerId = null;
    }
    get Logon() {
        return this.locoLogon;
    }
    async login(deviceUUID, accessToken) {
        if (!this.Connected) {
            throw new Error('Not connected to LOCO');
        }
        if (this.locoLogon) {
            throw new Error('Already logon to LOCO');
        }
        let config = this.ConfigProvider.Configuration;
        let packet = new packet_login_1.PacketLoginReq(deviceUUID, accessToken, config.appVersion, config.agent, config.deviceType, config.netType, config.mccmnc, config.language);
        let res = await this.requestPacketRes(packet);
        this.locoLogon = true;
        this.schedulePing();
        return res;
    }
    schedulePing() {
        if (!this.Connected) {
            return;
        }
        this.pingSchedulerId = setTimeout(this.schedulePing.bind(this), NetworkManager.PING_INTERVAL);
        this.sendPacket(new packet_ping_1.PacketPingReq());
    }
    disconnected() {
        super.disconnected();
        if (this.pingSchedulerId)
            clearTimeout(this.pingSchedulerId);
        this.locoLogon = false;
    }
}
exports.MainInterface = MainInterface;
//# sourceMappingURL=network-manager.js.map