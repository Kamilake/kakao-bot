"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocoSecureSocket = void 0;
const loco_socket_1 = require("./loco-socket");
const crypto_manager_1 = require("../secure/crypto-manager");
const net = require("net");
const loco_encrypted_transformer_1 = require("./stream/loco-encrypted-transformer");
const loco_packet_resolver_1 = require("./stream/loco-packet-resolver");
class LocoSecureSocket extends loco_socket_1.LocoBasicSocket {
    constructor(pubKey, receiver, host, port, keepAlive) {
        super(receiver, host, port, keepAlive);
        this.handshaked = false;
        this.crypto = new crypto_manager_1.CryptoManager(pubKey);
    }
    get Handshaked() {
        return this.handshaked;
    }
    pipeTranformation(socket) {
        socket.pipe(new loco_encrypted_transformer_1.LocoEncryptedTransformer(this)).pipe(new loco_packet_resolver_1.LocoPacketResolver(this));
    }
    transformBuffer(data) {
        if (this.handshaked) {
            let encryptedPacketBuffer = this.Crypto.toEncryptedPacket(super.transformBuffer(data), this.crypto.randomCipherIV());
            return encryptedPacketBuffer;
        }
        return super.transformBuffer(data);
    }
    async connect() {
        let res = await super.connect();
        let handshaked = await this.handshake();
        if (!handshaked)
            throw new Error('Handshake failed');
        return res;
    }
    async handshake() {
        if (!this.Connected || this.handshaked) {
            return false;
        }
        return this.sendHandshakePacket();
    }
    async sendHandshakePacket() {
        let keyBuffer = this.Crypto.getRSAEncryptedKey();
        let handshakeBuffer = Buffer.allocUnsafe(12 + keyBuffer.byteLength);
        handshakeBuffer.writeUInt32LE(keyBuffer.length, 0);
        handshakeBuffer.writeUInt32LE(12, 4);
        handshakeBuffer.writeUInt32LE(2, 8);
        keyBuffer.copy(handshakeBuffer, 12);
        let res = await super.sendBuffer(handshakeBuffer);
        return this.handshaked = res;
    }
    createSocketConnection(host, port, callback) {
        this.handshaked = false;
        return net.connect({
            host: host,
            port: port,
            timeout: 15000
        }, callback).setKeepAlive(this.KeepAlive).setNoDelay(true);
    }
    get Crypto() {
        return this.crypto;
    }
    onConnect() {
    }
    onConnected() {
    }
    onEnd(buffer) {
    }
    onError(err) {
        super.onError(err);
    }
}
exports.LocoSecureSocket = LocoSecureSocket;
//# sourceMappingURL=loco-secure-socket.js.map