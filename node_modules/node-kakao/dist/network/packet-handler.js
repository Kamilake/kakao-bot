"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TalkPacketHandler = void 0;
const events_1 = require("events");
const packet_kickout_1 = require("../packet/packet-kickout");
const loco_packet_base_1 = require("../packet/loco-packet-base");
const open_link_type_1 = require("../talk/open/open-link-type");
class TalkPacketHandler extends events_1.EventEmitter {
    constructor(networkManager) {
        super();
        this.kickReason = packet_kickout_1.LocoKickoutType.UNKNOWN;
        this.networkManager = networkManager;
        this.setMaxListeners(1000);
        this.on('LOGINLIST', this.onLogin.bind(this));
        this.on('MSG', this.onMessagePacket.bind(this));
        this.on('NEWMEM', this.onNewMember.bind(this));
        this.on('DECUNREAD', this.onMessageRead.bind(this));
        this.on('JOINLINK', this.onOpenChannelJoin.bind(this));
        this.on('REWRITE', this.onRewrite.bind(this));
        this.on('SYNCLINKCR', this.syncOpenChannelJoin.bind(this));
        this.on('SETMEMTYPE', this.onMemberTypeChange.bind(this));
        this.on('SYNCMEMT', this.onMemberTypeChange.bind(this));
        this.on('SYNCLINKPF', this.syncProfileUpdate.bind(this));
        this.on('SYNCREWR', this.syncRewrite.bind(this));
        this.on('UPLINKPROF', this.syncClientProfileUpdate.bind(this));
        this.on('SETMETA', this.onMetaChange.bind(this));
        this.on('CHGMETA', this.onMetaChange.bind(this));
        this.on('KICKMEM', this.onOpenChannelKick.bind(this));
        this.on('DELMEM', this.onMemberDelete.bind(this));
        this.on('LINKKICKED', this.onLinkKicked.bind(this));
        this.on('LNKDELETED', this.onLinkDeleted.bind(this));
        this.on('SYNCDLMSG', this.syncMessageDelete.bind(this));
        this.on('LEFT', this.onChannelLeft.bind(this));
        this.on('LEAVE', this.onChannelLeave.bind(this));
        this.on('KICKLEAVE', this.onChannelLeave.bind(this));
        this.on('RELAYEVENT', this.onRelayEvent.bind(this));
        this.on('CHANGESVR', this.onSwitchServerReq.bind(this));
        this.on('KICKOUT', this.onLocoKicked.bind(this));
    }
    get NetworkManager() {
        return this.networkManager;
    }
    get Client() {
        return this.networkManager.Client;
    }
    get ChatManager() {
        return this.Client.ChatManager;
    }
    get ChannelManager() {
        return this.Client.ChannelManager;
    }
    get UserManager() {
        return this.Client.UserManager;
    }
    onRequest(packetId, packet) {
    }
    onResponse(packetId, packet, reqPacket) {
        this.emit(packet.PacketName, packet, reqPacket);
    }
    onDisconnected() {
        if (this.kickReason !== packet_kickout_1.LocoKickoutType.CHANGE_SERVER) {
            this.Client.emit('disconnected', this.kickReason);
        }
    }
    getManagedChannel(id) {
        return this.ChannelManager.get(id);
    }
    async onLogin(packet) {
        await this.Client.updateStatus();
    }
    async onMessagePacket(packet) {
        if (!packet.Chatlog)
            return;
        let channel = this.getManagedChannel(packet.ChannelId);
        let chatLog = packet.Chatlog;
        let isNewChannel = false;
        if (!channel) {
            channel = await this.ChannelManager.addChannel(packet.ChannelId);
            if (!channel)
                return;
            isNewChannel = true;
        }
        let chat = this.ChatManager.chatFromChatlog(chatLog);
        if (!chat)
            return;
        if (isNewChannel) {
            this.Client.ClientUser.emit('user_join', channel, this.Client.ClientUser, chat);
            channel.emit('user_join', channel, this.Client.ClientUser, chat);
            this.Client.emit('user_join', channel, this.Client.ClientUser, chat);
        }
        let managedInfo = channel.getManagedUserInfo(chat.Sender);
        if (managedInfo)
            managedInfo.updateNickname(packet.SenderNickname);
        channel.updateLastChat(chat);
        chat.Sender.emit('message', chat);
        channel.emit('message', chat);
        this.Client.emit('message', chat);
        if (!chat.isFeed())
            return;
        chat.Sender.emit('feed', chat);
        channel.emit('feed', chat);
        this.Client.emit('feed', chat);
    }
    onMessageRead(packet) {
        let channel = this.getManagedChannel(packet.ChannelId);
        if (!channel)
            return;
        let reader = this.UserManager.get(packet.ReaderId);
        let watermark = packet.Watermark;
        reader.emit('message_read', channel, reader, watermark);
        channel.emit('message_read', channel, reader, watermark);
        this.Client.emit('message_read', channel, reader, watermark);
    }
    onMetaChange(packet) {
        if (!packet.Meta)
            return;
        let channel = this.getManagedChannel(packet.ChannelId);
        if (!channel)
            return;
        let lastMeta = channel.getChannelMeta(packet.Meta.type);
        channel.updateMeta(packet.Meta.type, packet.Meta);
        channel.emit('meta_changed', channel, packet.Meta.type, packet.Meta, lastMeta);
        this.Client.emit('meta_changed', channel, packet.Meta.type, packet.Meta, lastMeta);
    }
    async onNewMember(packet) {
        if (!packet.Chatlog)
            return;
        let channel = this.getManagedChannel(packet.Chatlog.channelId);
        if (!channel) {
            channel = await this.ChannelManager.addChannel(packet.Chatlog.channelId);
            if (!channel)
                return;
        }
        let chatlog = packet.Chatlog;
        let chat = this.Client.ChatManager.chatFromChatlog(chatlog);
        if (!chat || !chat.isFeed())
            return;
        let feed = chat.getFeed();
        let idList;
        if ('members' in feed)
            idList = feed.members.map((feedMemberStruct) => feedMemberStruct.userId);
        else
            idList = [];
        let infoList;
        if (idList.length > 0)
            infoList = (await this.UserManager.requestUserInfoList(channel, idList)).result;
        else
            infoList = [];
        for (let i = 0; i < idList.length; i++) {
            let id = idList[i];
            let userInfo = infoList[i];
            let user = this.UserManager.get(id);
            if (!user.isClientUser()) {
                channel.updateUserInfo(id, userInfo);
            }
            user.emit('user_join', channel, user, chat);
            channel.emit('user_join', channel, user, chat);
            this.Client.emit('user_join', channel, user, chat);
            user.emit('feed', chat);
        }
        channel.emit('feed', chat);
        this.Client.emit('feed', chat);
    }
    syncMessageDelete(packet) {
        if (!packet.Chatlog)
            return;
        let chat = this.ChatManager.chatFromChatlog(packet.Chatlog);
        if (!chat || !chat.isFeed())
            return;
        chat.Sender.emit('message_deleted', chat);
        chat.Channel.emit('message_deleted', chat);
        this.Client.emit('message_deleted', chat);
        chat.Sender.emit('feed', chat);
        chat.Channel.emit('feed', chat);
        this.Client.emit('feed', chat);
    }
    onChannelLeft(packet) {
        let channel = this.getManagedChannel(packet.ChannelId);
        if (!channel)
            return;
        this.Client.ClientUser.emit('user_left', channel, this.Client.ClientUser);
        channel.emit('user_left', channel, this.Client.ClientUser);
        this.Client.emit('user_left', channel, this.Client.ClientUser);
        this.ChannelManager.removeChannel(channel.Id);
    }
    onChannelLeave(packet, reqPacket) {
        if (!reqPacket || !reqPacket.ChannelId)
            return;
        let channel = this.getManagedChannel(reqPacket.ChannelId);
        if (!channel)
            return;
        if (packet.StatusCode !== loco_packet_base_1.StatusCode.SUCCESS)
            return;
        this.Client.ClientUser.emit('user_left', channel, this.Client.ClientUser);
        channel.emit('user_left', channel, this.Client.ClientUser);
        this.Client.emit('user_left', channel, this.Client.ClientUser);
        this.ChannelManager.removeChannel(channel.Id);
    }
    onLinkKicked(packet) {
        if (!packet.Chatlog)
            return;
        let chat = this.ChatManager.chatFromChatlog(packet.Chatlog);
        if (!chat || !chat.isFeed())
            return;
        let channel = chat.Channel;
        let user = this.UserManager.get(chat.Feed.member.userId);
        user.emit('user_kicked', channel, user, chat);
        channel.emit('user_kicked', channel, user, chat);
        this.Client.emit('user_kicked', channel, user, chat);
        user.emit('feed', chat);
        channel.emit('feed', chat);
        this.Client.emit('feed', chat);
        this.ChannelManager.removeChannel(channel.Id);
    }
    onLinkDeleted(packet) {
        if (!packet.Chatlog)
            return;
        let chat = this.ChatManager.chatFromChatlog(packet.Chatlog);
        if (!chat || !chat.isFeed())
            return;
        chat.Channel.emit('link_deleted', chat.Channel, chat);
        this.Client.emit('link_deleted', chat.Channel, chat);
    }
    onOpenChannelJoin(packet) {
        if (!packet.Chatlog)
            return;
        let chat = this.ChatManager.chatFromChatlog(packet.Chatlog);
        if (!chat || !chat.isFeed())
            return;
        let channel = chat.Channel;
        this.Client.ClientUser.emit('user_join', channel, this.Client.ClientUser);
        channel.emit('user_join', channel, this.Client.ClientUser);
        this.Client.emit('user_join', channel, this.Client.ClientUser);
        this.Client.ClientUser.emit('feed', chat);
        channel.emit('feed', chat);
        this.Client.emit('feed', chat);
    }
    onRewrite(packet, reqPacket) {
        if (!reqPacket)
            return;
        let channel = this.ChannelManager.get(reqPacket.ChannelId);
        if (!channel)
            return;
        channel.emit('message_hidden', channel, reqPacket.LogId);
        this.Client.emit('message_hidden', channel, reqPacket.LogId);
    }
    async syncOpenChannelJoin(packet) {
        if (!packet.ChatInfo)
            return;
        let chanId = packet.ChatInfo.channelId;
        if (this.ChannelManager.has(chanId) || !packet.ChatInfo)
            return;
        let newChan = await this.ChannelManager.addWithChannelInfo(chanId, packet.ChatInfo);
        this.Client.ClientUser.emit('user_join', newChan, this.Client.ClientUser);
        newChan.emit('user_join', newChan, this.Client.ClientUser);
        this.Client.emit('user_join', newChan, this.Client.ClientUser);
    }
    async onMemberTypeChange(packet) {
        let chanId = packet.ChannelId;
        let channel = this.getManagedChannel(chanId);
        if (!channel || !channel.isOpenChat())
            return;
        let len = packet.MemberIdList.length;
        for (let i = 0; i < len; i++) {
            let info = channel.getUserInfoId(packet.MemberIdList[i]);
            let type = packet.MemberTypeList[i];
            if (!info)
                continue;
            let lastType = info.MemberType;
            let managedInfo = channel.getManagedUserInfoId(packet.MemberIdList[i]);
            if (managedInfo)
                managedInfo.updateMemberType(type);
            if (type === open_link_type_1.OpenMemberType.OWNER) {
                let link = channel.getOpenLink();
                let prevHost = this.UserManager.get(link.LinkOwnerInfo.Id);
                await this.Client.OpenLinkManager.updateInfo(link);
                info.User.emit('link_hand_over_host', channel, info.User, prevHost);
                channel.emit('link_hand_over_host', channel, info.User, prevHost);
                this.Client.emit('link_hand_over_host', channel, info.User, prevHost);
                continue;
            }
            info.User.emit('member_type_changed', channel, info.User, lastType);
            channel.emit('member_type_changed', channel, info.User, lastType);
            this.Client.emit('member_type_changed', channel, info.User, lastType);
        }
    }
    syncClientProfileUpdate(packet, reqPacket) {
        if (!packet.UpdatedProfile)
            return;
        let channel = this.ChannelManager.findOpenChatChannel(reqPacket.LinkId);
        if (!channel)
            return;
        let user = this.UserManager.get(packet.UpdatedProfile.userId);
        let lastInfo = channel.getUserInfo(user);
        let changedProfileType = packet.UpdatedProfile.profileType;
        if (!lastInfo)
            return;
        channel.updateUserInfo(user.Id, this.UserManager.getInfoFromStruct(packet.UpdatedProfile));
        user.emit('profile_changed', channel, user, lastInfo, changedProfileType);
        channel.emit('profile_changed', channel, user, lastInfo, changedProfileType);
        this.Client.emit('profile_changed', channel, user, lastInfo, changedProfileType);
    }
    syncProfileUpdate(packet) {
        let chanId = packet.ChannelId;
        if (!packet.OpenMember)
            return;
        let channel = this.getManagedChannel(chanId);
        if (!channel || !channel.isOpenChat())
            return;
        let user = this.UserManager.get(packet.OpenMember.userId);
        let lastInfo = channel.getUserInfo(user);
        let changedProfileType = packet.OpenMember.profileType;
        if (!lastInfo)
            return;
        channel.updateUserInfo(user.Id, this.UserManager.getInfoFromStruct(packet.OpenMember));
        user.emit('profile_changed', channel, user, lastInfo, changedProfileType);
        channel.emit('profile_changed', channel, user, lastInfo, changedProfileType);
        this.Client.emit('profile_changed', channel, user, lastInfo, changedProfileType);
    }
    syncRewrite(packet) {
        if (!packet.Chatlog)
            return;
        let chat = this.ChatManager.chatFromChatlog(packet.Chatlog);
        if (!chat || !chat.isFeed())
            return;
        chat.Channel.emit('message_hidden', chat.Channel, chat.Feed.logId, chat);
        this.Client.emit('message_hidden', chat.Channel, chat.Feed.logId, chat);
        chat.Sender.emit('feed', chat);
        chat.Channel.emit('feed', chat);
        this.Client.emit('feed', chat);
    }
    onOpenChannelKick(packet) {
        if (!packet.Chatlog)
            return;
        let chat = this.ChatManager.chatFromChatlog(packet.Chatlog);
        if (!chat || !chat.isFeed())
            return;
        let channel = chat.Channel;
        let feed = chat.getFeed();
        if (!feed.member)
            return;
        let kickedUser = this.UserManager.get(feed.member.userId);
        kickedUser.emit('user_kicked', channel, kickedUser, chat);
        channel.emit('user_kicked', channel, kickedUser, chat);
        this.Client.emit('user_kicked', channel, kickedUser, chat);
        this.Client.emit('feed', chat);
        if (this.Client.ClientUser !== kickedUser)
            channel.updateUserInfo(feed.member.userId, null);
    }
    onMemberDelete(packet) {
        if (!packet.Chatlog)
            return;
        let chatLog = packet.Chatlog;
        let chat = this.ChatManager.chatFromChatlog(chatLog);
        if (!chat || !chat.isFeed())
            return;
        let channel = chat.Channel;
        let feed = chat.getFeed();
        if (!feed.member)
            return;
        let leftUser = this.UserManager.get(feed.member.userId);
        leftUser.emit('user_left', channel, leftUser, chat);
        channel.emit('user_left', channel, leftUser, chat);
        this.Client.emit('user_left', channel, leftUser, chat);
        leftUser.emit('user_kicked', channel, leftUser, chat);
        channel.emit('user_kicked', channel, leftUser, chat);
        this.Client.emit('user_kicked', channel, leftUser, chat);
        leftUser.emit('feed', chat);
        channel.emit('feed', chat);
        this.Client.emit('feed', chat);
        channel.updateUserInfo(feed.member.userId, null);
    }
    onRelayEvent(packet) {
        let openChannel = this.getManagedChannel(packet.ChannelId);
        if (!openChannel)
            return;
        let user = this.UserManager.get(packet.AutherId);
        openChannel.emit('chat_event', openChannel, user, packet.EventType, packet.EventCount, packet.LogId);
        this.Client.emit('chat_event', openChannel, user, packet.EventType, packet.EventCount, packet.LogId);
    }
    onSwitchServerReq(packet) {
        let accessData = this.Client.Auth.getLatestAccessData();
        this.Client.emit('switch_server');
        this.networkManager.getCheckinData(accessData.userId, true).then(() => {
            this.kickReason = packet_kickout_1.LocoKickoutType.CHANGE_SERVER;
            this.networkManager.disconnect();
            this.Client.relogin();
        });
    }
    onLocoKicked(packet) {
        let reason = packet.Reason;
        this.kickReason = reason;
    }
}
exports.TalkPacketHandler = TalkPacketHandler;
//# sourceMappingURL=packet-handler.js.map