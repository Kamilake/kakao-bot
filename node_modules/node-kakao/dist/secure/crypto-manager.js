"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoManager = void 0;
const crypto = require("crypto");
class CryptoManager {
    constructor(pubKey, key = crypto.randomBytes(16)) {
        this.pubKey = pubKey;
        this.key = key;
    }
    get Key() {
        return this.key;
    }
    get PEMPublicKey() {
        return this.pubKey;
    }
    bufferToBinaryString(buffer) {
        return buffer.toString('binary');
    }
    binaryStringToBuffer(str) {
        return Buffer.from(str, 'binary');
    }
    toAESEncrypted(buffer, iv) {
        let cipher = crypto.createCipheriv('aes-128-cfb', this.key, iv);
        return Buffer.concat([cipher.update(buffer), cipher.final()]);
    }
    toAESDecrypted(buffer, iv) {
        let cipher = crypto.createDecipheriv('aes-128-cfb', this.key, iv);
        return Buffer.concat([cipher.update(buffer), cipher.final()]);
    }
    toRSAEncrypted(buffer) {
        return crypto.publicEncrypt(this.PEMPublicKey, buffer);
    }
    toEncryptedPacket(packetBuffer, cipherIV) {
        let encryptedBuf = this.toAESEncrypted(packetBuffer, cipherIV);
        let buffer = Buffer.allocUnsafe(encryptedBuf.byteLength + 20);
        buffer.writeUInt32LE(encryptedBuf.length + 16, 0);
        cipherIV.copy(buffer, 4);
        encryptedBuf.copy(buffer, 20);
        return buffer;
    }
    randomCipherIV() {
        return crypto.randomBytes(16);
    }
    toDecryptedPacketBuffer(encryptedPacketBuffer, cipherIV) {
        return this.toAESDecrypted(encryptedPacketBuffer, cipherIV);
    }
    getRSAEncryptedKey() {
        return this.toRSAEncrypted(this.key);
    }
}
exports.CryptoManager = CryptoManager;
//# sourceMappingURL=crypto-manager.js.map